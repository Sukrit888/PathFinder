# -*- coding: utf-8 -*-
"""my_pathfinder

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yTwD4UDNgzqPY7KclyT3MkADIQ1pBZQe
"""

import heapq
import math

class Graph:
    def __init__(self):
        self.edges = {}
        self.coordinates = {}

    def add_edge(self, u, v, weight):
        if u not in self.edges:
            self.edges[u] = []
        self.edges[u].append((v, weight))
        if v not in self.edges:
            self.edges[v] = []
        self.edges[v].append((u, weight))  # For undirected graph

    def add_coordinates(self, node, x, y):
        self.coordinates[node] = (x, y)

    def heuristic(self, node1, node2):
        x1, y1 = self.coordinates.get(node1, (0, 0))
        x2, y2 = self.coordinates.get(node2, (0, 0))
        return math.sqrt((x1 - x2)**2 + (y1 - y2)**2)

    def dijkstra(self, start, end):
        pq = [(0, start, [])]
        visited = set()

        while pq:
            (dist, current, path) = heapq.heappop(pq)
            if current in visited:
                continue
            visited.add(current)
            path = path + [current]
            if current == end:
                return path, dist
            for neighbor, weight in self.edges.get(current, []):
                if neighbor not in visited:
                    heapq.heappush(pq, (dist + weight, neighbor, path))
        return [], float('inf')

    def astar(self, start, end):
        pq = [(0 + self.heuristic(start, end), 0, start, [])]
        visited = set()

        while pq:
            (est_total, cost_so_far, current, path) = heapq.heappop(pq)
            if current in visited:
                continue
            visited.add(current)
            path = path + [current]
            if current == end:
                return path, cost_so_far
            for neighbor, weight in self.edges.get(current, []):
                if neighbor not in visited:
                    g = cost_so_far + weight
                    h = self.heuristic(neighbor, end)
                    f = g + h
                    heapq.heappush(pq, (f, g, neighbor, path))
        return [], float('inf')